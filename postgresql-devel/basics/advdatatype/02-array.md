If you're a programmer, you know that an array holds a _list_ or _collection_ of values. In Postgres, the array can hold a set of values of other data types (i.e. a set of integers, or enums, or even user-defined types). 

With that said, while in some programming languages such as JavaScript, you different data types in the same array, in Postgres the array elements are of the **same** type.

### Declare array type

We've decided that our `career_interests` column in the client table should be 
an array. This lets us store **multiple** career interest text values 
per person, instead of storing them as one long text string, and perhaps doing 
something like parsing the string using delimiters (e.g. commas) to 
actually get each individual interest.

Let's create the first table in our example:

```
CREATE TABLE client (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	first VARCHAR(50) NOT NULL,
	last VARCHAR(50),
	email VARCHAR(80) NOT NULL,
    career_interests TEXT[] NOT NULL
);
```

The simplest way to set the column type to an array is to add square brackets `[]`
 to the type name for the values in that column -- which is what we've 
 done in the CREATE TABLE statement above. 
 
While you can specify an array size, e.g. `career_interests[5]`, Postgres 
won't actually enforce the size. If you needed to limit the number of array 
elements, you could use a [CHECK constraint](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS).

### Add array values

Let's add some records to our table:

```
INSERT INTO client (first, last, email, career_interests) 
    VALUES ('Wilhelmina', 'Wybrow', 'wwybrow0@elegantthemes.com', '{"Programming", "Project Management", "Web Development"}'),
        ('Domenic', 'Perotti', 'dperotti2@blog.com', '{"Athletic coaching", "personal training"}'),
        ('Mart', 'Wellbelove', 'mwellbelove3@ibm.com', '{"Computer Programming", "Data Science"}'),
        ('Ricky', 'MacGillivray', 'rmacgillivray4@eepurl.com', '{"Counseling"}'),
        ('Nina', 'Ferrand', 'nferrand5@lycos.com', '{"Music", "Audio engineering", "Radio", "Film Production", "Screenwriting"}');
```

There are two ways to add array values to a table. One is to use curly braces 
enclosed by quotes, as we've done above: 

> '{value1 delimiter value2 delimiter value3 ...}'

The delimiter for almost all data types is the comma (`,`).

The other way is to use the [ARRAY constructor](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS):

> `INSERT INTO client (..., career_interests)
VALUES (..., ARRAY ['Social media', 'Communications', 'PR'])

Note the differences in syntax:
* curly braces (`{}`), versus square brackets (`[]`),
* double quotes (`""`) around literals inside the braces, versus single quotes 
(`''`) around literals inside the brackets
* enclose curly brackets in single quotes

### Query arrays

Let's start with a simple SELECT on the table:

```
SELECT * FROM client;
```

You'll notice that the text values that contain whitespaces (e.g. `Project 
Management`) are enclosed by double quotes. Numeric arrays won't contain 
quotes, but textual arrays may or may not contain them. The [official docs](https://www.postgresql.org/docs/current/arrays.html#ARRAYS-IO) has details on how array values are outputted.

Array elements each have a position. Postgres uses a **one-based** numbering 
convention for arrays; that is, the first array element is `array[1]`, and 
the last of **n** elements is `array[n]`.

So, you could access the first career interest for clients like so:

```
SELECT 
    first,
    last,
    career_interests[1]
FROM client;
```

With that said, that's not particularly helpful for our case, so let's look at 
a couple of functions that come in handy for arrays.

### A few helpful functions

#### `unnest()`

Instead of returning the array elements within the same row, you can use 
[`unnest()`]() to expand the array to multiple rows:

```
SELECT 
    first,
    last,
    unnest(career_interests)
FROM client;
```

`unnest()` returns a [set](https://www.postgresql.org/docs/current/xfunc-sql.html#XFUNC-SQL-FUNCTIONS-RETURNING-SET).
 Each element gets one row, and the data type for each value matches the 
 original type (in this case, `text`).

`unnest()` also opens up the door for working further with the array values; for example, querying using wildcards:

```
SELECT first, last, interest 
FROM (SELECT    first, 
                last, 
                unnest(career_interests) as interest
    FROM client) c 
WHERE interest LIKE '%Programming';
```

#### `ANY()`

You might be interested in finding records that have a specific career 
interest. The [`ANY()`](https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.28.16) function lets you search arrays:

```
SELECT 
    first,
    last,
    career_interests
FROM client
WHERE 'Developer' = ANY(career_interests);
```
>**Note**:
>
>It is possible to index array columns. Indexing is beyond the scope of this 
course, but you'll likely look into a [GIN index](https://www.postgresql.org/docs/current/gin.html) for arrays.

#### `array_to_string()`

Postgres can help you process and format array data. For example, `array_to_string()` is a function that takes in an array, a delimiter, and an optional null string as arguments, and concatenates the array elements into `text`.

```
SELECT
    first,
    last,
    array_to_string(career_interests, ' | ') 
FROM client;
```

### Update an array

You can modify an entire array or part of an array (by individual element, or slice).

To replace an entire array:

```
UPDATE client
SET career_interests = '{ "Product Management", "UX" }'
WHERE id = 3;

SELECT * FROM client;
```

You can push a new element to either the beginning or end of the array using 
the `array_prepend()` or `array_append()` [functions](https://www.postgresql.org/docs/current/functions-array.html).
 Alternatively the concatenation (`||`) operator lets you push a single element
  or another array to the existing array as well:

```
UPDATE client
SET career_interests = career_interests || ARRAY['Personal Coaching', 'Community Management']
WHERE id = 4;

SELECT * FROM client;
```

### So when should I use the array type?

It comes down to how you'll be working with the data. While you are able to 
search arrays for individual elements, and indexing can help speed up that 
operation, it might be more efficient to store the data in separate lookup 
tables instead.

The array type would be better suited for if you mostly plan on processing, 
analyzing or reporting on these values as an aggregate, or perhaps if you're 
expecting thousands of elements.

### Links

[postgresql.org: Arrays](https://www.postgresql.org/docs/current/arrays.html)  
[postgresql.org: Array Functions and Operators](https://www.postgresql.org/docs/current/functions-array.html)
