Range types are unique to Postgres. Range types allow you to store a _range_ of
 values of a particular _subtype_ (i.e. some other data type such as 
 `numeric`). You would then use a range to check whether something falls within
  or outside of the range, or before 
 or after the range _bounds_. It's also helpful for finding overlapping ranges.

 The built-in range types in Postgres have 
 either numeric or date/time subtypes, implying that common uses involve some 
 measure of time or numeric data. Scheduling or 
 calendar applications are great candidates, as are . You can also create your own range types, per
  the
   [official docs](https://www.postgresql.org/docs/current/rangetypes.html).

In our business scenario, we're using a field `event_dt` to store datetime ranges for Extra Mile Consulting's event offerings. We'll set it to the `tstzrange`, which is for `timestamp with time zone`.

### Declare range type

Let's create our event table:

```
CREATE TYPE event_mode AS ENUM ('Virtual', 'In-person');

CREATE TABLE event (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    event_dt tstzrange NOT NULL,
    mode event_mode NOT NULL
);
```

This table also includes the enum type field `mode`, which we'll look at later.

### Add range values

Let's go ahead and add some events:

```
INSERT INTO event (name, event_dt, mode)
    VALUES ('Individual Appointment', '[2019-12-02 14:30 PST, 2019-12-02 15:30 PST)', 'In-person'),
            ('Individual Appointment', '[2019-12-11 17:00 EST, 2019-12-11 17:30 EST)', 'Virtual'),
            ('Resume and Cover Letter Workshop', '[2019-12-14 10:00 PST, 2019-12-14 12:00 PST)', 'In-person'),
            ('Interview Practice', '[2020-01-11 09:00 PST, 2020-01-11 12:00 PST)', 'In-person')
;
```

Let's take a closer look at the `tstzrange` syntax we used:

`'[2019-12-02 14:30 PST, 2019-12-02 15:30 PST)'`

Range are expressed with lower and upper **bounds**, and these bounds can be 
_inclusive_ or _exclusive_ of the boundary points. A square bracket (`[` or `]`) denotes an exclusive bound, and parentheses (`(` or `)`) denotes inclusive. So in the snippet above, we are saying that the event time range is _inclusive_ of the start time at 2:30PM PST, but exclusive of the end time at 3:30PM PST.

We can also use a constructor function to add range values - the name of the function is the same as the name of the type. Here's an example for `tstzrange`:

```
INSERT INTO event (name, event_dt, mode)
VALUES ('Test Event', 
        tstzrange('2019-12-14 12:00:00 EST', '2019-12-14 17:00:00 EST', '[)'),
        'Virtual'        
);
```

### A few helpful functions and operators

#### `lower()` and `upper()`

The `lower()` and `upper()` functions return the lower and upper boundaries 
of the range, respectively:

```
SELECT lower(event_dt) AT TIME ZONE 'America/Los_Angeles' AS "Start Time",
        upper(event_dt) AT TIME ZONE 'America/Los_Angeles' AS "End Time",
        name AS "Event Name"
FROM event
ORDER BY "Start Time";
```

(`AT TIME ZONE` will return a `timestamp without time zone` value in the 
specified time zone, so in this query we're showing all timestamps on West 
Coast time. Recall that timezone can also be set with the `TimeZone` parameter,
 which is something you could do in your application code as well so that it 
 matches the user/client's time zone.)

#### Contains (`<@`>)

Let's say we want to know what events have been scheduled at a particular day 
and time. We can use the `<@` operator to check whether some event in 
our table _contains_ that desired time:

```
SELECT * FROM event
WHERE event_dt @> '2020-06-26 16:30:00 PDT'::timestamptz;
```

(The timestamps should be in UTC per this environment's `TimeZone` setting.)

#### Overlap (`&&`)

We could also write a query that shows us if there are any events that have 
overlapped in schedule:

```
SELECT lower(e1.event_dt) AT TIME ZONE 'America/Los_Angeles' AS "Start Time",
        upper(e1.event_dt) AT TIME ZONE 'America/Los_Angeles' AS "End Time",
        e1.name AS "Event Name"
FROM event AS e1
JOIN event AS e2 ON e1.event_dt && e2.event_dt AND e1.id != e2.id
ORDER BY "Start Time";
```

>**Note:**
>
>In this scenario, we haven't specified a business rule that no events can 
overlap. We can enforce this rule with an EXCLUDE constraint -- which we cover in this [course](../constraints/).

### Links

[postgresql.org: Range Types](https://www.postgresql.org/docs/current/rangetypes.html)  
[postgresql.org: Range Functions and Operators](https://www.postgresql.org/docs/current/functions-range.html)
